# Notes on 8 September 2020

## Agenda:
- Mutable state and the `Learner`
    - What constitutes state? When does it need to be mutated?
      | State                | Example of mutation                          |
      |:---------------------|:---------------------------------------------|
      | Model (architecture) | Pruning methods                              |
      | Model (parameters)   | Pruning methods, weight clipping             |
      | Data                 | Adversarial training                         |
      | Optimizer            | Hyperparameter tuning                        |
      | Augmentation Flow    | Hyperparameter tuning                        |
    - Prevent multiple callbacks from overriding each other
        
        - Does functional programming prevent this?
    - Designing the callback system as a series of transforms
    - What is misuse of an API? Used in a way that violates assumptions?
    
- Parallel training

- Triage system



## Minutes

- Kyle and Peter will start triage project
- FastAI.jl is Peter's project on Github
  - Immediate concern when starting port: callbacks had references back to `Learner`
  - Lots of hidden semantics in Python code
  - Desire to do something different in Julia

### Mutability and Callback State

- Two concerns about state:
  - Semantically invalid state
  - Memory mutation (concern for parallel code)
- Allow mutations to mess with stuff to allow flexibility
- Every callback can crash the training

#### Possible Solutions

- Read-only callbacks are guaranteed to be safe
  - Can't always be read-only; not flexible
  - For example, we need to move data to GPU
- Have a log to show when CBs run and what state is modified
  - Upfront introspection
  - Debug tool for user
- Registry for CBs before running
- Pure functions
  - Julia doesn't allow immutable function arguments by default
  - Don't mix mutable and immutable argument interfaces
  - Good strategy for multi-threaded safety

### Callback Ordering

**Problem:** Some callbacks depend on the state of other callbacks. For example, a `Logger` depends on the history generated by a `Recorder`. That means `Logger` must run after `Recorder`.

*Complication 1:* `Recorder` might not be aware of `Logger`. This means callbacks have to specify what they depend on (`Logger` depends on `Recorder`) and not what depends on them (`Recorder` is depended on by `Logger`).

*Complication 2:* The state of the dependee has to be accessed by the dependency, e.g. the `Logger` has to access the history created by `Recorder`. State accessed that way should probably be read-only by default as well, since there may be multiple depending callbacks.

**Some notes:**

- `_order` parameter in fast.ai
  - CBs set parameters like -9999 to guarantee first in order
- Flux accepts a vector of CBs; ordering based on order of vector
- Use Dagger.jl or Base tasks to encode dependency graph
  - Need a way to do topological sorting of callbacks (guarantees correctness)

## Action Items

- **Kyle** and **Peter** will work on triage system
- **Everyone** (if motivated) will implement callback ordering system